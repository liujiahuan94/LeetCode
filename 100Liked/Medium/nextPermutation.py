def nextPermutation(nums):
    # 找到序列数字组成的比当前数字大的最小整数
    # 两种情况：1、数字是最大的了，直接返回最小值（逆序）；2、正常情况
    # 思路有两点：
    #（1）首先倒序遍历数组，找到不是升序的地方。如果全是升序，就是最大值了，直接逆序即可
    # 如果有不是升序的地方，那么这个数字就是一个峰值，要作为一个分界线。例如，123542中的5
    # 接着找到分界点右侧第一个大于左侧的数字，将它们交换，这就是保证了左侧数字变大。但是是最小的
    # 如果分界点右侧没有大于左侧的，就叫交换边界点本身，所以边界条件就是检索到分界点处
    # 然后将分界点及其右边的数字全部逆序（保证变小）

    # 起始点为最后，准备逆序遍历
    i = j = len(nums)-1
    while i > 0 and nums[i] <= nums[i-1]:
        i -= 1
    
    # 本身是升序的，直接反转
    if i == 0:
        nums.reverse()
        return
    
    # 找到分界点左边的数字
    k = i - 1

    # 遍历分界点及其右侧的数字，找到第一个大于分界点左侧的数字
    while nums[j] <= nums[k]:
        j -= 1
    
    # 交换它们
    nums[j], nums[k] = nums[k], nums[j]
    # 定位到分界点
    l = k + 1
    r = len(nums) - 1
    # 分界点及其右侧的所有数字逆序，使其变小
    while l < r:
        nums[l], nums[r] = nums[r], nums[l]
        l += 1
        r -= 1